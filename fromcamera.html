<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Particle Engine 1080p (Camera Tracking)</title>
    <style>
        body {
            margin: 0;
            background-color: #050505;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }

        #canvas-wrapper {
            position: relative;
            /* Force 16:9 aspect ratio */
            width: 100%;
            max-width: 1920px;
            aspect-ratio: 16 / 9; 
            max-height: 100vh;
            background-color: #000;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border: 1px solid #222;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #camera {
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        #camera-preview {
            position: absolute;
            left: 16px;
            bottom: 16px;
            width: 200px;
            height: 112px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            border-radius: 6px;
            background: #000;
        }

        #camera-controls {
            position: absolute;
            left: 16px;
            bottom: 140px;
            background: rgba(0, 0, 0, 0.55);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 10px 12px;
            pointer-events: auto;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        #camera-controls button {
            background: #1d2a33;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e5f4ff;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
        }

        #camera-controls button:hover {
            background: #263844;
        }

        #camera-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .ui-layer {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: none;
            opacity: 0.6;
        }
    </style>
</head>
<body>

    <div id="canvas-wrapper">
        <canvas id="world"></canvas>
        <video id="camera" autoplay playsinline muted></video>
        <canvas id="camera-preview"></canvas>
        <div id="camera-controls">
            <strong>Camera Mapping</strong>
            <button id="calibrate-btn" type="button">Calibrate 10s</button>
            <button id="reset-mapping-btn" type="button">Reset Mapping</button>
            <div id="mapping-status">Mapping: Full Frame</div>
        </div>
        <div class="ui-layer">
            <h3>Particle Emitter</h3>
            <p>Emitter: Center | Attractor: Camera</p>
            <p id="camera-status">Camera: Starting...</p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.18.0/dist/lil-gui.umd.min.js"></script>

    <script>
        // --- 1. Setup Canvas & Context ---
        const canvas = document.getElementById('world');
        const ctx = canvas.getContext('2d');

        // Internal resolution (1080p)
        const width = 1920;
        const height = 1080;
        canvas.width = width;
        canvas.height = height;

        // Camera tracking state (default to center-ish so particles flow somewhere initially)
        const tracker = { x: width * 0.7, y: height * 0.5, active: false, brightness: 0 };

        function canvasToWorld(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }

        const video = document.getElementById('camera');
        const cameraPreview = document.getElementById('camera-preview');
        const cameraStatus = document.getElementById('camera-status');
        const mappingStatus = document.getElementById('mapping-status');
        const calibrateButton = document.getElementById('calibrate-btn');
        const resetMappingButton = document.getElementById('reset-mapping-btn');
        const cameraCtx = cameraPreview.getContext('2d', { willReadFrequently: true });
        let cameraReady = false;

        // --- 2. Configuration & GUI ---
        const config = {
            // Emission
            emitRate: 5,         // Particles per frame
            particleSpeed: 14.63,
            lifeSpan: 200,       // How long particles live
            
            // Visuals
            startColor: '#ffffff',
            endColor: '#0000ff',
            lineWidth: 2,
            fadeEffect: 0.1,     // Trail fade (lower = longer trails)

            // Mask
            maskImageSrc: 'fern.jpg',

            // Physics
            randomness: 1.975,     // Jitter/Noise
            friction: 0.95969,      // Air resistance
            
            // Attractor
            attractRadius: 649.8,
            attractStrength: 1.8081,
            enableAttractor: true,

            // Repulsion
            enableRepulsion: true,
            repulseRadius: 250,
            repulseStrength: 1.2,

            // Camera Tracking
            trackingThreshold: 210,
            trackingSmoothing: 0.2,
            mirrorCamera: true,
            flipCameraVertical: false,
            cropStereoRight: false,
            showTracker: true
        };

        const gui = new lil.GUI({ title: 'Engine Settings' });
        
        const fVisuals = gui.addFolder('Visuals');
        fVisuals.addColor(config, 'startColor').name('Start Color');
        fVisuals.addColor(config, 'endColor').name('End Color');
        fVisuals.add(config, 'lineWidth', 0.1, 10).name('Line Width');
        fVisuals.add(config, 'fadeEffect', 0.01, 0.5).name('Trail Fade (Clear)').step(0.01);

        const fPhysics = gui.addFolder('Movement');
        fPhysics.add(config, 'particleSpeed', 1, 20).name('Launch Speed');
        fPhysics.add(config, 'randomness', 0, 5).name('Randomness (Jitter)');
        fPhysics.add(config, 'friction', 0.8, 0.99).name('Friction');

        const fAttract = gui.addFolder('Attractor');
        fAttract.add(config, 'enableAttractor').name('Enable Camera Pull');
        fAttract.add(config, 'attractRadius', 50, 1000).name('Range');
        fAttract.add(config, 'attractStrength', 0.1, 5).name('Strength');

        const fRepulse = gui.addFolder('Repulsion');
        fRepulse.add(config, 'enableRepulsion').name('Enable Click Push');
        fRepulse.add(config, 'repulseRadius', 50, 1000).name('Radius');
        fRepulse.add(config, 'repulseStrength', 0.1, 5).name('Strength');

        const fCamera = gui.addFolder('Camera Tracking');
        fCamera.add(config, 'trackingThreshold', 0, 255).name('Brightness Threshold');
        fCamera.add(config, 'trackingSmoothing', 0, 0.5).name('Smoothing').step(0.01);
        fCamera.add(config, 'mirrorCamera').name('Mirror');
        fCamera.add(config, 'flipCameraVertical').name('Flip Vertical');
        fCamera.add(config, 'cropStereoRight').name('Crop Right Half (Stereo)');
        fCamera.add(config, 'showTracker').name('Show Tracker');

        const trailCanvas = document.createElement('canvas');
        const trailCtx = trailCanvas.getContext('2d');
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');
        const imageCanvas = document.createElement('canvas');
        const imageCtx = imageCanvas.getContext('2d');

        [trailCanvas, maskCanvas, imageCanvas].forEach((surface) => {
            surface.width = width;
            surface.height = height;
        });

        const maskImage = new Image();
        maskImage.decoding = 'async';
        maskImage.src = config.maskImageSrc;
        let maskImageReady = false;
        maskImage.onload = () => {
            maskImageReady = true;
        };
        maskImage.onerror = () => {
            maskImageReady = false;
        };

        const cameraWidth = 320;
        const cameraHeight = 180;
        cameraPreview.width = cameraWidth;
        cameraPreview.height = cameraHeight;

        const mappingBounds = {
            minX: 0,
            minY: 0,
            maxX: cameraWidth - 1,
            maxY: cameraHeight - 1,
            ready: false
        };

        const calibration = {
            active: false,
            startTime: 0,
            durationMs: 30000,
            minX: 0,
            minY: 0,
            maxX: 0,
            maxY: 0,
            hasData: false
        };

        function setCameraStatus(text) {
            if (cameraStatus) {
                cameraStatus.textContent = text;
            }
        }

        function setMappingStatus(text) {
            if (mappingStatus) {
                mappingStatus.textContent = text;
            }
        }

        function startCalibration() {
            if (!cameraReady) {
                setMappingStatus('Mapping: Camera not ready');
                return;
            }
            calibration.active = true;
            mappingBounds.ready = false;
            calibration.startTime = performance.now();
            calibration.minX = Infinity;
            calibration.minY = Infinity;
            calibration.maxX = -Infinity;
            calibration.maxY = -Infinity;
            calibration.hasData = false;
            setMappingStatus('Mapping: Calibrating (10.0s)');
        }

        function resetMapping() {
            calibration.active = false;
            mappingBounds.minX = 0;
            mappingBounds.minY = 0;
            mappingBounds.maxX = cameraWidth - 1;
            mappingBounds.maxY = cameraHeight - 1;
            mappingBounds.ready = false;
            setMappingStatus('Mapping: Full Frame');
        }

        if (calibrateButton) {
            calibrateButton.disabled = true;
        }

        async function startCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                setCameraStatus('Camera: Not supported');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' },
                    audio: false
                });
                video.srcObject = stream;
                await video.play();
                cameraReady = true;
                setCameraStatus('Camera: On');
                if (calibrateButton) {
                    calibrateButton.disabled = false;
                }
            } catch (err) {
                cameraReady = false;
                setCameraStatus('Camera: Blocked');
                if (calibrateButton) {
                    calibrateButton.disabled = true;
                }
                console.warn('Camera error:', err);
            }
        }

        startCamera();

        if (calibrateButton) {
            calibrateButton.addEventListener('click', startCalibration);
        }

        if (resetMappingButton) {
            resetMappingButton.addEventListener('click', resetMapping);
        }

        window.addEventListener('keydown', (event) => {
            if (event.key === 'c' || event.key === 'C') {
                startCalibration();
            }
            if (event.key === 'r' || event.key === 'R') {
                resetMapping();
            }
        });

        // --- 3. Helper Functions ---
        
        // Convert Hex to RGB for interpolation
        function hexToRgb(hex) {
            const bigint = parseInt(hex.replace('#', ''), 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }

        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function drawImageCover(ctx, image, targetWidth, targetHeight) {
            const imageRatio = image.width / image.height;
            const targetRatio = targetWidth / targetHeight;
            let drawWidth = targetWidth;
            let drawHeight = targetHeight;
            let offsetX = 0;
            let offsetY = 0;

            if (imageRatio > targetRatio) {
                drawHeight = targetHeight;
                drawWidth = targetHeight * imageRatio;
                offsetX = (targetWidth - drawWidth) * 0.5;
            } else {
                drawWidth = targetWidth;
                drawHeight = targetWidth / imageRatio;
                offsetY = (targetHeight - drawHeight) * 0.5;
            }

            ctx.drawImage(image, offsetX, offsetY, drawWidth, drawHeight);
        }

        function getActiveBounds() {
            if (calibration.active && calibration.hasData) {
                return calibration;
            }
            if (mappingBounds.ready) {
                return mappingBounds;
            }
            return null;
        }

        function updateCalibrationStatus(now) {
            if (!calibration.active) {
                return;
            }

            const elapsed = now - calibration.startTime;
            const remaining = Math.max(0, calibration.durationMs - elapsed);
            setMappingStatus(`Mapping: Calibrating (${(remaining / 1000).toFixed(1)}s)`);

            if (elapsed >= calibration.durationMs) {
                calibration.active = false;
                if (calibration.hasData && calibration.maxX > calibration.minX && calibration.maxY > calibration.minY) {
                    mappingBounds.minX = calibration.minX;
                    mappingBounds.minY = calibration.minY;
                    mappingBounds.maxX = calibration.maxX;
                    mappingBounds.maxY = calibration.maxY;
                    mappingBounds.ready = true;
                    setMappingStatus('Mapping: Calibrated');
                } else {
                    mappingBounds.ready = false;
                    setMappingStatus('Mapping: Full Frame');
                }
            }
        }

        function updateCameraTracking() {
            updateCalibrationStatus(performance.now());
            if (!cameraReady || video.readyState < 2) {
                tracker.active = false;
                return;
            }

            {
                const flipX = config.mirrorCamera ? -1 : 1;
                const flipY = config.flipCameraVertical ? -1 : 1;
                const drawX = flipX === -1 ? -cameraWidth : 0;
                const drawY = flipY === -1 ? -cameraHeight : 0;
                const sourceWidth = video.videoWidth || cameraWidth;
                const sourceHeight = video.videoHeight || cameraHeight;
                let sourceX = 0;
                let sourceY = 0;
                let sourceW = sourceWidth;
                let sourceH = sourceHeight;

                if (config.cropStereoRight) {
                    sourceW = Math.max(1, Math.floor(sourceWidth / 2));
                }

                cameraCtx.save();
                cameraCtx.scale(flipX, flipY);
                cameraCtx.drawImage(
                    video,
                    sourceX,
                    sourceY,
                    sourceW,
                    sourceH,
                    drawX,
                    drawY,
                    cameraWidth,
                    cameraHeight
                );
                cameraCtx.restore();
            }

            const frame = cameraCtx.getImageData(0, 0, cameraWidth, cameraHeight);
            const data = frame.data;
            let bestValue = -1;
            let bestIndex = -1;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const value = Math.max(r, g, b);

                if (value > bestValue) {
                    bestValue = value;
                    bestIndex = i;
                }
            }

            if (bestIndex >= 0 && bestValue >= config.trackingThreshold) {
                const pixelIndex = bestIndex / 4;
                const x = pixelIndex % cameraWidth;
                const y = Math.floor(pixelIndex / cameraWidth);
                const activeBounds = getActiveBounds();
                const boundsMinX = activeBounds ? activeBounds.minX : 0;
                const boundsMinY = activeBounds ? activeBounds.minY : 0;
                const boundsMaxX = activeBounds ? activeBounds.maxX : cameraWidth - 1;
                const boundsMaxY = activeBounds ? activeBounds.maxY : cameraHeight - 1;
                const spanX = Math.max(1, boundsMaxX - boundsMinX);
                const spanY = Math.max(1, boundsMaxY - boundsMinY);
                const normalizedX = (x - boundsMinX) / spanX;
                const normalizedY = (y - boundsMinY) / spanY;
                const targetX = clamp(normalizedX, 0, 1) * width;
                const targetY = clamp(normalizedY, 0, 1) * height;
                const smoothing = config.trackingSmoothing;

                if (tracker.active && smoothing > 0) {
                    tracker.x = lerp(tracker.x, targetX, smoothing);
                    tracker.y = lerp(tracker.y, targetY, smoothing);
                } else {
                    tracker.x = targetX;
                    tracker.y = targetY;
                }

                tracker.active = true;
                tracker.brightness = bestValue;

                if (calibration.active) {
                    calibration.minX = Math.min(calibration.minX, x);
                    calibration.minY = Math.min(calibration.minY, y);
                    calibration.maxX = Math.max(calibration.maxX, x);
                    calibration.maxY = Math.max(calibration.maxY, y);
                    calibration.hasData = true;
                }
            } else {
                tracker.active = false;
                tracker.brightness = 0;
            }

            const overlayBounds = getActiveBounds();
            if (overlayBounds) {
                cameraCtx.save();
                cameraCtx.strokeStyle = calibration.active ? 'rgba(255, 196, 0, 0.9)' : 'rgba(80, 200, 255, 0.9)';
                cameraCtx.lineWidth = 2;
                cameraCtx.strokeRect(
                    overlayBounds.minX,
                    overlayBounds.minY,
                    overlayBounds.maxX - overlayBounds.minX,
                    overlayBounds.maxY - overlayBounds.minY
                );
                cameraCtx.restore();
            }

            if (config.showTracker && tracker.active) {
                cameraCtx.save();
                cameraCtx.fillStyle = 'rgba(0, 255, 120, 0.9)';
                cameraCtx.beginPath();
                cameraCtx.arc(
                    (tracker.x / width) * cameraWidth,
                    (tracker.y / height) * cameraHeight,
                    4,
                    0,
                    Math.PI * 2
                );
                cameraCtx.fill();
                cameraCtx.restore();
            }
        }

        // --- 4. Particle System ---
        
        let particles = [];
        let repulsor = null;

        canvas.addEventListener('click', (e) => {
            if (!config.enableRepulsion) return;
            const pos = canvasToWorld(e);
            if (!repulsor) {
                repulsor = { x: pos.x, y: pos.y };
            } else {
                repulsor.x = pos.x;
                repulsor.y = pos.y;
            }
        });

        class Particle {
            constructor() {
                // Start at center
                this.x = width / 2;
                this.y = height / 2;
                
                // Random initial velocity
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * config.particleSpeed;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                // Track previous position for drawing smooth lines
                this.prevX = this.x;
                this.prevY = this.y;

                this.life = 0;
                this.maxLife = config.lifeSpan + Math.random() * 50;
                this.dead = false;
            }

            update() {
                // 1. Save previous position
                this.prevX = this.x;
                this.prevY = this.y;

                // 2. Attractor Physics
                if (config.enableAttractor && tracker.active) {
                    const dx = tracker.x - this.x;
                    const dy = tracker.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < config.attractRadius) {
                        // Calculate pull force (stronger when closer)
                        const force = config.attractStrength * (1 - dist / config.attractRadius);
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                }

                // 3. Repulsors
                if (config.enableRepulsion && repulsor) {
                    const dx = this.x - repulsor.x;
                    const dy = this.y - repulsor.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0 && dist < config.repulseRadius) {
                        const force = config.repulseStrength * (1 - dist / config.repulseRadius);
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                }

                // 4. Randomness (Jitter)
                this.vx += (Math.random() - 0.5) * config.randomness;
                this.vy += (Math.random() - 0.5) * config.randomness;

                // 5. Move
                this.x += this.vx;
                this.y += this.vy;

                // 6. Friction
                this.vx *= config.friction;
                this.vy *= config.friction;

                // 7. Aging
                this.life++;
                if (this.life > this.maxLife) {
                    this.dead = true;
                }
            }

            draw(trailCtx, maskCtx) {
                const progress = this.life / this.maxLife;
                const startRgb = hexToRgb(config.startColor);
                const whiteAlpha = Math.max(0, 1 - progress);

                trailCtx.strokeStyle = `rgba(${startRgb[0]},${startRgb[1]},${startRgb[2]},${whiteAlpha})`;
                trailCtx.lineWidth = config.lineWidth;
                trailCtx.lineCap = 'round';

                trailCtx.beginPath();
                trailCtx.moveTo(this.prevX, this.prevY);
                trailCtx.lineTo(this.x, this.y);
                trailCtx.stroke();

                maskCtx.strokeStyle = `rgba(255,255,255,${progress})`;
                maskCtx.lineWidth = config.lineWidth;
                maskCtx.lineCap = 'round';

                maskCtx.beginPath();
                maskCtx.moveTo(this.prevX, this.prevY);
                maskCtx.lineTo(this.x, this.y);
                maskCtx.stroke();
            }
        }

        // --- 5. Animation Loop ---

        function animate() {
            updateCameraTracking();

            // Create trails by fading the offscreen buffers.
            trailCtx.fillStyle = `rgba(0, 0, 0, ${config.fadeEffect})`;
            trailCtx.fillRect(0, 0, width, height);
            maskCtx.globalCompositeOperation = 'destination-out';
            maskCtx.fillStyle = `rgba(0, 0, 0, ${config.fadeEffect})`;
            maskCtx.fillRect(0, 0, width, height);
            maskCtx.globalCompositeOperation = 'source-over';

            // Spawn new particles
            for (let i = 0; i < config.emitRate; i++) {
                particles.push(new Particle());
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw(trailCtx, maskCtx);

                if (p.dead) {
                    particles.splice(i, 1);
                }
            }

            // Compose final frame
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            ctx.drawImage(trailCanvas, 0, 0);

            if (maskImageReady) {
                imageCtx.clearRect(0, 0, width, height);
                drawImageCover(imageCtx, maskImage, width, height);
                imageCtx.globalCompositeOperation = 'destination-in';
                imageCtx.drawImage(maskCanvas, 0, 0);
                imageCtx.globalCompositeOperation = 'source-over';
                ctx.drawImage(imageCanvas, 0, 0);
            }

            if (config.showTracker && tracker.active) {
                ctx.strokeStyle = 'rgba(120, 200, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(tracker.x, tracker.y, 12, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw repulsor rings
            if (config.enableRepulsion && repulsor) {
                ctx.strokeStyle = 'rgba(255, 120, 120, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(repulsor.x, repulsor.y, config.repulseRadius, 0, Math.PI * 2);
                ctx.stroke();
            }

            requestAnimationFrame(animate);
        }

        // Start
        animate();

    </script>
</body>
</html>
