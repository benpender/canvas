<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgpu - attractors particles with masked projection</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif; }
            a { color: #fff; }
        </style>
    </head>
    <body>

        <script type="importmap">
            {
                "imports": {
                    "three": "./three/build/three.webgpu.js",
                    "three/webgpu": "./three/build/three.webgpu.js",
                    "three/tsl": "./three/build/three.tsl.js",
                    "three/addons/": "./three/addons/"
                }
            }
        </script>

        <script type="module">

            import * as THREE from 'three/webgpu';
            // Removed 'discard' from imports to fix the error
            import { float, If, PI, color, cos, instanceIndex, Loop, mix, mod, sin, instancedArray, Fn, uint, uniform, uniformArray, hash, vec3, vec4, texture } from 'three/tsl';

            import { Inspector } from 'three/addons/inspector/Inspector.js';

            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            import { TransformControls } from 'three/addons/controls/TransformControls.js';

            let camera, scene, renderer, controls, updateCompute;
            let attractors = [];
            let statusState = null;
            let attractorStatus = [];
            let cameraState = null;
            let cameraControls = null;
            let imuSocket = null;
            const imuState = {
                roll: 0,
                pitch: 0,
                yaw: 0,
                lastUpdate: 0,
                connected: false
            };
            const imuDebug = true;
            let lastImuLog = 0;
            const defaultImuHost = '10.0.0.151';
            const imuHost = ( window.location.hostname && window.location.hostname !== 'localhost' )
                ? window.location.hostname
                : defaultImuHost;
            const imuConfig = {
                url: `ws://${imuHost}:81`,
                timeoutMs: 1000,
                mapping: {
                    order: 'XYZ',
                    roll: { axis: 'x', sign: 1 },
                    pitch: { axis: 'y', sign: 1 },
                    yaw: { axis: 'z', sign: 1 }
                }
            };
            const imuAxisEnabled = {
                roll: true,
                pitch: true,
                yaw: true
            };
            const imuEuler = new THREE.Euler();
            const imuAxis = new THREE.Vector3();

            const roundValue = ( value ) => Math.round( value * 1000 ) / 1000;
            const syncCameraValue = ( control, state, key, value ) => {

                const rounded = roundValue( value );

                if ( state ) {
                    state[ key ] = rounded;
                }

                if ( ! control || ! control.input || document.activeElement === control.input ) {
                    return;
                }

                const current = parseFloat( control.input.value );
                if ( Number.isNaN( current ) || current !== rounded ) {
                    control.input.value = rounded;
                }

            };

            const connectImu = () => {
                if ( imuSocket ) {
                    imuSocket.close();
                }

                imuSocket = new WebSocket( imuConfig.url );

                imuSocket.addEventListener( 'open', () => {
                    imuState.connected = true;
                    if ( imuDebug ) console.log( '[IMU] connected', imuConfig.url );
                } );

                imuSocket.addEventListener( 'close', () => {
                    imuState.connected = false;
                    if ( imuDebug ) console.log( '[IMU] disconnected' );
                    setTimeout( connectImu, 1000 );
                } );

                imuSocket.addEventListener( 'error', ( event ) => {
                    if ( imuDebug ) console.log( '[IMU] error', event );
                } );

                imuSocket.addEventListener( 'message', ( event ) => {
                    try {
                        const data = JSON.parse( event.data );
                        if ( Number.isFinite( data.roll ) && Number.isFinite( data.pitch ) && Number.isFinite( data.yaw ) ) {
                            imuState.roll = data.roll;
                            imuState.pitch = data.pitch;
                            imuState.yaw = data.yaw;
                            imuState.lastUpdate = performance.now();
                            if ( imuDebug ) {
                                const now = performance.now();
                                if ( now - lastImuLog >= 1000 ) {
                                    console.log( '[IMU] update', imuState );
                                    lastImuLog = now;
                                }
                            }
                        }
                    } catch ( err ) {
                        if ( imuDebug ) console.log( '[IMU] parse error', err, event.data );
                    }
                } );
            };

            const applyImuRotation = ( attractor ) => {
                let rx = 0;
                let ry = 0;
                let rz = 0;

                const quantizeDeg = ( value ) => Math.round( value / 5 ) * 5;
                const rollDeg = imuAxisEnabled.roll ? quantizeDeg( imuState.roll * imuConfig.mapping.roll.sign ) : 0;
                const pitchDeg = imuAxisEnabled.pitch ? quantizeDeg( imuState.pitch * imuConfig.mapping.pitch.sign ) : 0;
                const yawDeg = imuAxisEnabled.yaw ? quantizeDeg( imuState.yaw * imuConfig.mapping.yaw.sign ) : 0;

                const rollRad = THREE.MathUtils.degToRad( rollDeg );
                const pitchRad = THREE.MathUtils.degToRad( pitchDeg );
                const yawRad = THREE.MathUtils.degToRad( yawDeg );

                if ( imuConfig.mapping.roll.axis === 'x' ) rx = rollRad;
                if ( imuConfig.mapping.roll.axis === 'y' ) ry = rollRad;
                if ( imuConfig.mapping.roll.axis === 'z' ) rz = rollRad;

                if ( imuConfig.mapping.pitch.axis === 'x' ) rx = pitchRad;
                if ( imuConfig.mapping.pitch.axis === 'y' ) ry = pitchRad;
                if ( imuConfig.mapping.pitch.axis === 'z' ) rz = pitchRad;

                if ( imuConfig.mapping.yaw.axis === 'x' ) rx = yawRad;
                if ( imuConfig.mapping.yaw.axis === 'y' ) ry = yawRad;
                if ( imuConfig.mapping.yaw.axis === 'z' ) rz = yawRad;

                imuEuler.set( rx, ry, rz, imuConfig.mapping.order );
                attractor.reference.rotation.copy( imuEuler );
                imuAxis.set( 0, 1, 0 ).applyEuler( imuEuler ).normalize();
                attractor.orientation.copy( imuAxis );
            };

            init();

            async function init() {

                camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );
                camera.position.set( 10, 0, 0 );

                scene = new THREE.Scene();

                // ambient light
                const ambientLight = new THREE.AmbientLight( '#ffffff', 0.5 );
                scene.add( ambientLight );

                // directional light
                const directionalLight = new THREE.DirectionalLight( '#ffffff', 1.5 );
                directionalLight.position.set( 4, 2, 0 );
                scene.add( directionalLight );

                // renderer
                renderer = new THREE.WebGPURenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setAnimationLoop( animate );
                renderer.setClearColor( '#000000' );
                renderer.inspector = new Inspector();
                document.body.appendChild( renderer.domElement );

                await renderer.init();

                controls = new OrbitControls( camera, renderer.domElement );
                controls.enableDamping = true;
                controls.minDistance = 0.1;
                controls.maxDistance = 50;

                window.addEventListener( 'resize', onWindowResize );
                connectImu();

                // -----------------------------------------------------------------
                // START: Projection Mask Setup
                // -----------------------------------------------------------------
                
                const loader = new THREE.TextureLoader();
                const personTexture = loader.load( 'person.jpg' );
                personTexture.colorSpace = THREE.SRGBColorSpace;

                const personMaterial = new THREE.SpriteNodeMaterial();
                
                // Enable depth writing so black pixels block things behind them
                personMaterial.depthWrite = true; 
                personMaterial.depthTest = true;
                
                // IMPORTANT: Set alphaTest. 
                // Any pixel with alpha < 0.5 is discarded (transparent/pass-through).
                // Any pixel with alpha >= 0.5 is kept (opaque/blocking).
                personMaterial.alphaTest = 0.5;

                personMaterial.colorNode = Fn( () => {
                    const texColor = texture( personTexture );
                    const brightness = texColor.r; 
                    
                    // Logic: 
                    // Start with Alpha = 1.0 (Opaque).
                    // If brightness > 0.5 (White), set Alpha = 0.0.
                    
                    const alpha = float( 1.0 ).toVar();
                    
                    If( brightness.greaterThan( 0.5 ), () => {
                        alpha.assign( 0.0 );
                    } );

                    // Return Black color with calculated alpha
                    return vec4( 0.0, 0.0, 0.0, alpha ); 

                } )();

                const personSprite = new THREE.Sprite( personMaterial );
                personSprite.position.set( 0, 0, 0 ); 
                personSprite.scale.set( 6, 6, 1 ); 
                scene.add( personSprite );

                // -----------------------------------------------------------------
                // END: Projection Mask Setup
                // -----------------------------------------------------------------


                // attractors
                const attractorsPositions = uniformArray( [
                    new THREE.Vector3( - 1, 0, 0 ),
                    new THREE.Vector3( 1, 0, - 0.5 ),
                    new THREE.Vector3( 0, 0.5, 1 )
                ] );
                const attractorsRotationAxes = uniformArray( [
                    new THREE.Vector3( 0, 1, 0 ),
                    new THREE.Vector3( 0, 1, 0 ),
                    new THREE.Vector3( 1, 0, - 0.5 ).normalize()
                ] );
                const attractorsLength = uniform( attractorsPositions.array.length, 'uint' );
                attractors = [];
                const helpersRingGeometry = new THREE.RingGeometry( 1, 1.02, 32, 1, 0, Math.PI * 1.5 );
                const helpersArrowGeometry = new THREE.ConeGeometry( 0.1, 0.4, 12, 1, false );
                const helpersMaterial = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide } );

                for ( let i = 0; i < attractorsPositions.array.length; i ++ ) {

                    const attractor = {};

                    attractor.position = attractorsPositions.array[ i ];
                    attractor.orientation = attractorsRotationAxes.array[ i ];
                    attractor.reference = new THREE.Object3D();
                    attractor.reference.position.copy( attractor.position );
                    attractor.reference.quaternion.setFromUnitVectors( new THREE.Vector3( 0, 1, 0 ), attractor.orientation );
                    scene.add( attractor.reference );

                    attractor.helper = new THREE.Group();
                    attractor.helper.scale.setScalar( 0.325 );
                    attractor.reference.add( attractor.helper );

                    attractor.ring = new THREE.Mesh( helpersRingGeometry, helpersMaterial );
                    attractor.ring.rotation.x = - Math.PI * 0.5;
                    attractor.helper.add( attractor.ring );

                    attractor.arrow = new THREE.Mesh( helpersArrowGeometry, helpersMaterial );
                    attractor.arrow.position.x = 1;
                    attractor.arrow.position.z = 0.2;
                    attractor.arrow.rotation.x = Math.PI * 0.5;
                    attractor.helper.add( attractor.arrow );

                    attractor.controls = new TransformControls( camera, renderer.domElement );
                    attractor.controls.mode = 'rotate';
                    attractor.controls.size = 0.5;
                    attractor.controls.attach( attractor.reference );
                    attractor.controls.visible = true;
                    attractor.controls.enabled = attractor.controls.visible;
                    scene.add( attractor.controls.getHelper() );

                    attractor.controls.addEventListener( 'dragging-changed', ( event ) => {

                        controls.enabled = ! event.value;

                    } );

                    attractor.controls.addEventListener( 'change', () => {

                        attractor.position.copy( attractor.reference.position );
                        attractor.orientation.copy( new THREE.Vector3( 0, 1, 0 ).applyQuaternion( attractor.reference.quaternion ) );

                    } );

                    attractors.push( attractor );

                }

                // particles

                const count = Math.pow( 2, 18 );
                const material = new THREE.SpriteNodeMaterial( { blending: THREE.AdditiveBlending, depthWrite: false } );

                const attractorMass = uniform( Number( `1e${7}` ) );
                const particleGlobalMass = uniform( Number( `1e${4}` ) );
                const timeScale = uniform( 1 );
                const spinningStrength = uniform( 2.75 );
                const maxSpeed = uniform( 8 );
                const gravityConstant = 6.67e-11;
                const velocityDamping = uniform( 0.1 );
                const scale = uniform( 0.008 );
                const boundHalfExtent = uniform( 8 );
                const colorA = uniform( color( '#5900ff' ) );
                const colorB = uniform( color( '#ffa575' ) );

                const positionBuffer = instancedArray( count, 'vec3' );
                const velocityBuffer = instancedArray( count, 'vec3' );

                const sphericalToVec3 = Fn( ( [ phi, theta ] ) => {

                    const sinPhiRadius = sin( phi );

                    return vec3(
                        sinPhiRadius.mul( sin( theta ) ),
                        cos( phi ),
                        sinPhiRadius.mul( cos( theta ) )
                    );

                } );

                // init compute

                const init = Fn( () => {

                    const position = positionBuffer.element( instanceIndex );
                    const velocity = velocityBuffer.element( instanceIndex );

                    const basePosition = vec3(
                        hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ),
                        hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ),
                        hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) )
                    ).sub( 0.5 ).mul( vec3( 5, 0.2, 5 ) );
                    position.assign( basePosition );

                    const phi = hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ).mul( PI ).mul( 2 );
                    const theta = hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ).mul( PI );
                    const baseVelocity = sphericalToVec3( phi, theta ).mul( 0.05 );
                    velocity.assign( baseVelocity );

                } );

                const initCompute = init().compute( count );

                const reset = () => {

                    renderer.compute( initCompute );

                };

                reset();

                // update compute

                const particleMassMultiplier = hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ).remap( 0.25, 1 ).toVar();
                const particleMass = particleMassMultiplier.mul( particleGlobalMass ).toVar();

                const update = Fn( () => {

                    const delta = float( 1 / 60 ).mul( timeScale ).toVar(); 
                    const position = positionBuffer.element( instanceIndex );
                    const velocity = velocityBuffer.element( instanceIndex );

                    // force

                    const force = vec3( 0 ).toVar();

                    Loop( attractorsLength, ( { i } ) => {

                        const attractorPosition = attractorsPositions.element( i );
                        const attractorRotationAxis = attractorsRotationAxes.element( i );
                        const toAttractor = attractorPosition.sub( position );
                        const distance = toAttractor.length();
                        const direction = toAttractor.normalize();

                        // gravity
                        const gravityStrength = attractorMass.mul( particleMass ).mul( gravityConstant ).div( distance.pow( 2 ) ).toVar();
                        const gravityForce = direction.mul( gravityStrength );
                        force.addAssign( gravityForce );

                        // spinning
                        const spinningForce = attractorRotationAxis.mul( gravityStrength ).mul( spinningStrength );
                        const spinningVelocity = spinningForce.cross( toAttractor );
                        force.addAssign( spinningVelocity );

                    } );

                    // velocity

                    velocity.addAssign( force.mul( delta ) );
                    const speed = velocity.length();
                    If( speed.greaterThan( maxSpeed ), () => {

                        velocity.assign( velocity.normalize().mul( maxSpeed ) );

                    } );
                    velocity.mulAssign( velocityDamping.oneMinus() );

                    // position

                    position.addAssign( velocity.mul( delta ) );

                    // box loop

                    const halfHalfExtent = boundHalfExtent.div( 2 ).toVar();
                    position.assign( mod( position.add( halfHalfExtent ), boundHalfExtent ).sub( halfHalfExtent ) );

                } );
                updateCompute = update().compute( count ).setName( 'Update Particles' );

                // nodes

                material.positionNode = positionBuffer.toAttribute();

                material.colorNode = Fn( () => {

                    const velocity = velocityBuffer.toAttribute();
                    const speed = velocity.length();
                    const colorMix = speed.div( maxSpeed ).smoothstep( 0, 0.5 );
                    const finalColor = mix( colorA, colorB, colorMix );

                    return vec4( finalColor, 1 );

                } )();

                material.scaleNode = particleMassMultiplier.mul( scale );

                // mesh

                const geometry = new THREE.PlaneGeometry( 1, 1 );
                const mesh = new THREE.InstancedMesh( geometry, material, count );
                scene.add( mesh );

                // debug

                const gui = renderer.inspector.createParameters( 'Parameters' );

                gui.add( { attractorMassExponent: attractorMass.value.toString().length - 1 }, 'attractorMassExponent', 1, 10, 1 ).onChange( value => attractorMass.value = Number( `1e${value}` ) );
                gui.add( { particleGlobalMassExponent: particleGlobalMass.value.toString().length - 1 }, 'particleGlobalMassExponent', 1, 10, 1 ).onChange( value => particleGlobalMass.value = Number( `1e${value}` ) );
                gui.add( maxSpeed, 'value', 0, 10, 0.01 ).name( 'maxSpeed' );
                gui.add( velocityDamping, 'value', 0, 0.1, 0.001 ).name( 'velocityDamping' );
                gui.add( spinningStrength, 'value', 0, 10, 0.01 ).name( 'spinningStrength' );
                gui.add( scale, 'value', 0, 0.1, 0.001 ).name( 'scale' );
                gui.add( boundHalfExtent, 'value', 0, 20, 0.01 ).name( 'boundHalfExtent' );
                gui.addColor( { color: colorA.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorA' ).onChange( value => colorA.value.set( value ) );
                gui.addColor( { color: colorB.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorB' ).onChange( value => colorB.value.set( value ) );
                gui.add( { controlsMode: attractors[ 0 ].controls.mode }, 'controlsMode', [ 'translate', 'rotate', 'none' ] ).onChange( value => {

                    for ( const attractor of attractors ) {

                        if ( value === 'none' ) {

                            attractor.controls.visible = false;
                            attractor.controls.enabled = false;

                        } else {

                            attractor.controls.visible = true;
                            attractor.controls.enabled = true;
                            attractor.controls.mode = value;

                        }

                    }

                } );

                gui.add( { helperVisible: attractors[ 0 ].helper.visible }, 'helperVisible' ).onChange( value => {

                    for ( const attractor of attractors ) {

                        attractor.helper.visible = value;

                    }

                } );

                gui.add( { reset }, 'reset' );

                const statusGroup = renderer.inspector.parameters.createGroup( 'Attractor Status' );
                statusState = { controlsMode: attractors[ 0 ].controls.mode };
                const statusModeControl = statusGroup.add( statusState, 'controlsMode', [ 'translate', 'rotate', 'none' ] ).name( 'controlsMode' );
                statusModeControl.listen();
                statusModeControl.select.disabled = true;

                attractorStatus = [];

                for ( let i = 0; i < attractors.length; i ++ ) {

                    const data = {
                        posX: 0,
                        posY: 0,
                        posZ: 0,
                        rotX: 0,
                        rotY: 0,
                        rotZ: 0
                    };

                    const folder = statusGroup.addFolder( `Attractor ${i + 1}` );
                    const posXControl = folder.add( data, 'posX' ).name( 'Pos X' );
                    const posYControl = folder.add( data, 'posY' ).name( 'Pos Y' );
                    const posZControl = folder.add( data, 'posZ' ).name( 'Pos Z' );
                    const rotXControl = folder.add( data, 'rotX' ).name( 'Rot X (deg)' );
                    const rotYControl = folder.add( data, 'rotY' ).name( 'Rot Y (deg)' );
                    const rotZControl = folder.add( data, 'rotZ' ).name( 'Rot Z (deg)' );

                    [ posXControl, posYControl, posZControl, rotXControl, rotYControl, rotZControl ].forEach( ( control ) => {
                        control.listen();
                        control.input.readOnly = true;
                        control.input.tabIndex = -1;
                    } );

                    attractorStatus.push( data );

                }

                const cameraGroup = renderer.inspector.parameters.createGroup( 'Camera' );

                const imuGroup = renderer.inspector.parameters.createGroup( 'IMU Mapping' );
                const imuRollControl = imuGroup.add( imuAxisEnabled, 'roll' ).name( 'Apply Roll (X)' );
                const imuPitchControl = imuGroup.add( imuAxisEnabled, 'pitch' ).name( 'Apply Pitch (Y)' );
                const imuYawControl = imuGroup.add( imuAxisEnabled, 'yaw' ).name( 'Apply Yaw (Z)' );
                [ imuRollControl, imuPitchControl, imuYawControl ].forEach( ( control ) => {
                    control.listen();
                } );

                const updateControlsTargetFromCamera = () => {

                    if ( ! controls ) return;

                    const distance = camera.position.distanceTo( controls.target );
                    const direction = new THREE.Vector3( 0, 0, - 1 ).applyEuler( camera.rotation );
                    controls.target.copy( camera.position ).add( direction.multiplyScalar( distance ) );
                    controls.update();

                };

                cameraState = {
                    posX: roundValue( camera.position.x ),
                    posY: roundValue( camera.position.y ),
                    posZ: roundValue( camera.position.z ),
                    rotX: roundValue( THREE.MathUtils.radToDeg( camera.rotation.x ) ),
                    rotY: roundValue( THREE.MathUtils.radToDeg( camera.rotation.y ) ),
                    rotZ: roundValue( THREE.MathUtils.radToDeg( camera.rotation.z ) ),
                    fov: roundValue( camera.fov )
                };

                cameraControls = {
                    posX: cameraGroup.add( cameraState, 'posX' ).name( 'Pos X' ),
                    posY: cameraGroup.add( cameraState, 'posY' ).name( 'Pos Y' ),
                    posZ: cameraGroup.add( cameraState, 'posZ' ).name( 'Pos Z' ),
                    rotX: cameraGroup.add( cameraState, 'rotX' ).name( 'Rot X (deg)' ),
                    rotY: cameraGroup.add( cameraState, 'rotY' ).name( 'Rot Y (deg)' ),
                    rotZ: cameraGroup.add( cameraState, 'rotZ' ).name( 'Rot Z (deg)' ),
                    fov: cameraGroup.add( cameraState, 'fov', 1, 120 ).name( 'FOV' )
                };

                cameraControls.posX.onChange( ( value ) => {
                    camera.position.x = value;
                } );
                cameraControls.posY.onChange( ( value ) => {
                    camera.position.y = value;
                } );
                cameraControls.posZ.onChange( ( value ) => {
                    camera.position.z = value;
                } );
                cameraControls.rotX.onChange( ( value ) => {
                    camera.rotation.x = THREE.MathUtils.degToRad( value );
                    updateControlsTargetFromCamera();
                } );
                cameraControls.rotY.onChange( ( value ) => {
                    camera.rotation.y = THREE.MathUtils.degToRad( value );
                    updateControlsTargetFromCamera();
                } );
                cameraControls.rotZ.onChange( ( value ) => {
                    camera.rotation.z = THREE.MathUtils.degToRad( value );
                    updateControlsTargetFromCamera();
                } );
                cameraControls.fov.onChange( ( value ) => {
                    camera.fov = value;
                    camera.updateProjectionMatrix();
                } );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            async function animate() {

                controls.update();

                const imuActive = imuState.connected && ( performance.now() - imuState.lastUpdate <= imuConfig.timeoutMs );
                if ( imuActive && attractors.length > 2 ) {
                    applyImuRotation( attractors[ 2 ] );
                } else if ( imuDebug && imuState.connected ) {
                    const now = performance.now();
                    if ( now - lastImuLog >= 1000 ) {
                        console.log( '[IMU] stale data', {
                            ageMs: now - imuState.lastUpdate,
                            timeoutMs: imuConfig.timeoutMs
                        } );
                        lastImuLog = now;
                    }
                }

                if ( statusState ) {

                    statusState.controlsMode = attractors[ 0 ].controls.mode;

                    for ( let i = 0; i < attractors.length; i ++ ) {

                        const reference = attractors[ i ].reference;
                        const data = attractorStatus[ i ];

                        data.posX = roundValue( reference.position.x );
                        data.posY = roundValue( reference.position.y );
                        data.posZ = roundValue( reference.position.z );
                        data.rotX = roundValue( THREE.MathUtils.radToDeg( reference.rotation.x ) );
                        data.rotY = roundValue( THREE.MathUtils.radToDeg( reference.rotation.y ) );
                        data.rotZ = roundValue( THREE.MathUtils.radToDeg( reference.rotation.z ) );

                    }

                }

                if ( cameraControls && cameraState ) {

                    syncCameraValue( cameraControls.posX, cameraState, 'posX', camera.position.x );
                    syncCameraValue( cameraControls.posY, cameraState, 'posY', camera.position.y );
                    syncCameraValue( cameraControls.posZ, cameraState, 'posZ', camera.position.z );
                    syncCameraValue( cameraControls.rotX, cameraState, 'rotX', THREE.MathUtils.radToDeg( camera.rotation.x ) );
                    syncCameraValue( cameraControls.rotY, cameraState, 'rotY', THREE.MathUtils.radToDeg( camera.rotation.y ) );
                    syncCameraValue( cameraControls.rotZ, cameraState, 'rotZ', THREE.MathUtils.radToDeg( camera.rotation.z ) );
                    syncCameraValue( cameraControls.fov, cameraState, 'fov', camera.fov );

                }

                renderer.compute( updateCompute );
                renderer.render( scene, camera );

            }

        </script>
    </body>
</html>