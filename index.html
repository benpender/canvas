<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LED Sender</title>
</head>
<body>
<canvas id="preview" width="160" height="160"></canvas>
<script>
    // Bare-bones Art-Net frame sender (8x8), no UI.
    const MATRIX_W = 8;
    const MATRIX_H = 8;
    const WS_URL = 'ws://localhost:8080';
    const SEND_FPS = 60;

    const preview = document.getElementById('preview');
    const pCtx = preview.getContext('2d');

    const socket = new WebSocket(WS_URL);
    const rgbData = new Uint8Array(MATRIX_W * MATRIX_H * 3);
    const sendData = new Uint8Array(rgbData.length + 1);
    let seq = 0;
    const PATTERN_SPEED = 0.7;

    function renderLines() {
        const t = performance.now() / 1000;
        let ptr = 0;
        for (let y = 0; y < MATRIX_H; y++) {
            for (let x = 0; x < MATRIX_W; x++) {
                const color = radialColor(x, y, t);
                rgbData[ptr++] = color[0];
                rgbData[ptr++] = color[1];
                rgbData[ptr++] = color[2];
            }
        }

        const cell = preview.width / MATRIX_W;
        pCtx.clearRect(0, 0, preview.width, preview.height);
        let i = 0;
        for (let y = 0; y < MATRIX_H; y++) {
            for (let x = 0; x < MATRIX_W; x++) {
                const r = rgbData[i];
                const g = rgbData[i + 1];
                const b = rgbData[i + 2];
                i += 3;
                pCtx.fillStyle = `rgb(${r},${g},${b})`;
                pCtx.fillRect(x * cell, y * cell, cell, cell);
            }
        }
    }

    function radialColor(x, y, t) {
        const cx = (MATRIX_W - 1) / 2;
        const cy = (MATRIX_H - 1) / 2;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt((dx * dx) + (dy * dy));
        const maxR = Math.sqrt((cx * cx) + (cy * cy));
        const rNorm = dist / maxR;

        const phase = (t * PATTERN_SPEED) % 1;
        const hue = (phase * 360) % 360;
        const rings = 8;
        const wave = Math.sin((rNorm * rings * Math.PI * 2) - (phase * Math.PI * 2));
        const ripple = wave > 0 ? wave : 0;
        const fade = clamp01(1 - rNorm);

        const chevron = chevronMask(x, y, t);
        const pulse = 0.65 + 0.35 * Math.sin(t * 2.4);
        const v = Math.pow(ripple * fade * chevron * pulse, 1.1);
        const rgb = hsvToRgb(hue, 0.95, v);
        return rgb;
    }

    function clamp01(v) {
        return Math.max(0, Math.min(1, v));
    }

    function hsvToRgb(h, s, v) {
        const c = v * s;
        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        const m = v - c;
        let r = 0, g = 0, b = 0;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }
        return [
            Math.round((r + m) * 255),
            Math.round((g + m) * 255),
            Math.round((b + m) * 255)
        ];
    }

    function chevronMask(x, y, t) {
        const nx = (x + 0.5) / MATRIX_W * 2 - 1;
        const ny = (y + 0.5) / MATRIX_H * 2 - 1;
        const tilt = nx * 0.8 + ny * 1.1;
        const zig = Math.abs(Math.sin((tilt * 6) + t * 2.2));
        return 0.35 + 0.65 * zig;
    }

    setInterval(() => {
        if (socket.readyState !== WebSocket.OPEN) return;
        renderLines();
        sendData[0] = seq;
        seq = (seq + 1) & 255;
        sendData.set(rgbData, 1);
        socket.send(sendData);
    }, 1000 / SEND_FPS);
</script>
</body>
</html>
