<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Three.js Bars Occluded by Stereo Depth Mask</title>
  <style>
    html, body { margin:0; padding:0; background:#000; overflow:hidden; }
    #hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 13px; line-height: 1.4;
      background: rgba(0,0,0,0.45); padding: 10px 12px; border-radius: 10px;
      max-width: 520px;
    }
    #debug {
      position: fixed; right: 12px; top: 12px; z-index: 10;
      display: none; gap: 10px; flex-direction: column;
    }
    .dbgCanvas {
      width: 320px; height: auto; border-radius: 10px;
      outline: 1px solid rgba(255,255,255,0.18);
      background: #111;
    }
    #controls { margin-top: 8px; }
    #controls details {
      background: rgba(0,0,0,0.35);
      padding: 8px 10px;
      border-radius: 10px;
    }
    #controls summary { cursor: pointer; font-weight: 600; }
    .ctlGroup { display: flex; flex-direction: column; gap: 6px; margin-top: 8px; }
    .ctlRow { display: flex; align-items: center; gap: 8px; }
    .ctlRow label { flex: 1 1 auto; }
    .ctlRow input[type="range"] { width: 150px; }
    .ctlVal { width: 52px; text-align: right; font-variant-numeric: tabular-nums; }
    #gl { position: fixed; inset: 0; }
    button { cursor: pointer; }
  </style>

</head>
<body>
  <div id="hud">
    <div><b>Bars + Stereo Depth Occlusion</b></div>
    <div>Keys: <b>D</b> toggle debug | <b>F</b> fullscreen</div>
    <div id="status">Starting…</div>
    <div id="controls">
      <details open>
        <summary>Depth Controls</summary>
        <div class="ctlGroup">
          <div class="ctlRow">
            <label for="stereoSideBySide">Stereo side-by-side</label>
            <input id="stereoSideBySide" type="checkbox" />
          </div>
          <div class="ctlRow">
            <label for="swapStereo">Swap left/right</label>
            <input id="swapStereo" type="checkbox" />
          </div>
          <div class="ctlRow">
            <label for="flipX">Flip X (mirror)</label>
            <input id="flipX" type="checkbox" />
          </div>
          <div class="ctlRow">
            <label for="flipY">Flip Y (upside-down)</label>
            <input id="flipY" type="checkbox" />
          </div>
          <div class="ctlRow">
            <label for="maxDisparity">Max disparity</label>
            <input id="maxDisparity" type="range" min="4" max="80" step="1" />
            <span class="ctlVal" data-out="maxDisparity"></span>
          </div>
          <div class="ctlRow">
            <label for="depthMin">Depth min</label>
            <input id="depthMin" type="range" min="0" max="1" step="0.01" />
            <span class="ctlVal" data-out="depthMin"></span>
          </div>
          <div class="ctlRow">
            <label for="depthMax">Depth max</label>
            <input id="depthMax" type="range" min="0" max="1" step="0.01" />
            <span class="ctlVal" data-out="depthMax"></span>
          </div>
          <div class="ctlRow">
            <label for="depthGamma">Depth gamma</label>
            <input id="depthGamma" type="range" min="0.3" max="3" step="0.05" />
            <span class="ctlVal" data-out="depthGamma"></span>
          </div>
          <div class="ctlRow">
            <label for="depthBinary">Binary depth</label>
            <input id="depthBinary" type="checkbox" />
          </div>
          <div class="ctlRow">
            <label for="depthCutoff">Depth cutoff</label>
            <input id="depthCutoff" type="range" min="0" max="1" step="0.01" />
            <span class="ctlVal" data-out="depthCutoff"></span>
          </div>
          <div class="ctlRow">
            <label for="depthCutoffFeather">Cutoff feather</label>
            <input id="depthCutoffFeather" type="range" min="0" max="0.3" step="0.01" />
            <span class="ctlVal" data-out="depthCutoffFeather"></span>
          </div>
          <div class="ctlRow">
            <label for="maskThreshold">Occlusion threshold</label>
            <input id="maskThreshold" type="range" min="0" max="1" step="0.01" />
            <span class="ctlVal" data-out="maskThreshold"></span>
          </div>
          <div class="ctlRow">
            <label for="maskFeather">Occlusion feather</label>
            <input id="maskFeather" type="range" min="0" max="0.3" step="0.01" />
            <span class="ctlVal" data-out="maskFeather"></span>
          </div>
          <div class="ctlRow">
            <label for="invertMask">Invert mask</label>
            <input id="invertMask" type="checkbox" />
          </div>
          <div class="ctlRow">
            <label for="matchWindow">Match window</label>
            <input id="matchWindow" type="range" min="0" max="3" step="1" />
            <span class="ctlVal" data-out="matchWindow"></span>
          </div>
          <div class="ctlRow">
            <label for="maxAvgCost">Max avg cost</label>
            <input id="maxAvgCost" type="range" min="2" max="50" step="1" />
            <span class="ctlVal" data-out="maxAvgCost"></span>
          </div>
          <div class="ctlRow">
            <label for="minUniqueness">Min uniqueness</label>
            <input id="minUniqueness" type="range" min="0" max="25" step="1" />
            <span class="ctlVal" data-out="minUniqueness"></span>
          </div>
          <div class="ctlRow">
            <label for="procScale">Proc scale</label>
            <input id="procScale" type="range" min="0.2" max="1" step="0.05" />
            <span class="ctlVal" data-out="procScale"></span>
          </div>
          <div class="ctlRow">
            <label for="depthIntervalMs">Depth interval (ms)</label>
            <input id="depthIntervalMs" type="range" min="0" max="200" step="10" />
            <span class="ctlVal" data-out="depthIntervalMs"></span>
          </div>
        </div>
      </details>
    </div>
  </div>

  <div id="debug">
    <canvas id="leftView" class="dbgCanvas" width="640" height="480"></canvas>
    <canvas id="rightView" class="dbgCanvas" width="640" height="480"></canvas>
    <canvas id="maskView" class="dbgCanvas" width="640" height="480"></canvas>
  </div>

  <!-- Hidden video input -->
  <video id="video" playsinline muted style="display:none;"></video>

  <canvas id="gl"></canvas>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    const statusEl = document.getElementById('status');
    const video = document.getElementById('video');
    const glCanvas = document.getElementById('gl');

    const debugWrap = document.getElementById('debug');
    const leftCanvas = document.getElementById('leftView');
    const rightCanvas = document.getElementById('rightView');
    const maskCanvas = document.getElementById('maskView');
    const leftCtx = leftCanvas.getContext('2d', { willReadFrequently: true });
    const rightCtx = rightCanvas.getContext('2d', { willReadFrequently: true });
    const maskCtx = maskCanvas.getContext('2d');
    maskCtx.imageSmoothingEnabled = true;

    // === User-tunable knobs ===
    const CFG = {
      // Bars
      barsCount: 24,
      barsSpeed: 0.30,         // world units per second
      barsThickness: 0.035,    // normalized in view height (since we're using ortho)
      barsGap: 0.02,

      // Mask
      maskThreshold: 0.55,     // 0..1, higher => fewer pixels considered "near"
      maskFeather: 0.08,       // soft edge; 0 = hard
      invertMask: false,       // if your mask comes out inverted, flip this

      // Stereo depth (disparity)
      stereoSideBySide: true,  // assumes stereo frame is side-by-side (L|R)
      swapStereo: false,       // swap left/right if your camera order is reversed
      flipX: true,             // flip horizontally (use both flipX+flipY for upside-down cameras)
      flipY: true,
      procScale: 0.5,          // processing resolution scale (relative to input)
      maxDisparity: 28,        // pixels to search (bigger = closer range)
      depthMin: 0.0,           // remap: normalized depth min
      depthMax: 1.0,           // remap: normalized depth max
      depthGamma: 1.0,         // gamma curve for depth display
      depthBinary: true,       // true => threshold depth to near/far
      depthCutoff: 0.35,       // cutoff in normalized depth
      depthCutoffFeather: 0.04,// soft edge around cutoff
      disparityStep: 1,        // step size for disparity search
      depthIntervalMs: 50,     // throttle depth updates (ms)
      matchWindow: 2,          // radius (2 => 5x5) for block matching
      maxAvgCost: 35,          // reject low-confidence matches (avg abs diff)
      minUniqueness: 0         // reject ambiguous matches (2nd best - best)
    };

    // === Three.js setup (2D-ish orthographic, perfect for projector output) ===
    const renderer = new THREE.WebGLRenderer({ canvas: glCanvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x000000, 1);

    // Ortho camera with normalized-ish coordinates: x in [-aspect, +aspect], y in [-1, +1]
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);
    camera.position.z = 1;

    function resize() {
      renderer.setSize(innerWidth, innerHeight);
      const aspect = innerWidth / innerHeight;
      camera.left = -aspect;
      camera.right = aspect;
      camera.top = 1;
      camera.bottom = -1;
      camera.updateProjectionMatrix();
    }
    addEventListener('resize', resize);
    resize();

    // === Mask texture (from a canvas) ===
    const maskTexture = new THREE.CanvasTexture(maskCanvas);
    maskTexture.minFilter = THREE.LinearFilter;
    maskTexture.magFilter = THREE.LinearFilter;
    maskTexture.wrapS = THREE.ClampToEdgeWrapping;
    maskTexture.wrapT = THREE.ClampToEdgeWrapping;

    // === Bars material: discard fragments where near-depth mask is present ===
    const barsMat = new THREE.ShaderMaterial({
      uniforms: {
        tMask: { value: maskTexture },
        threshold: { value: CFG.maskThreshold },
        feather: { value: CFG.maskFeather },
        invertMask: { value: CFG.invertMask ? 1.0 : 0.0 }
      },
      transparent: false,
      depthTest: false,
      depthWrite: false,
      vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D tMask;
        uniform float threshold;
        uniform float feather;
        uniform float invertMask;
        varying vec2 vUv;

        void main() {
          // Depth mask: near ~ white, far ~ black.
          float m = texture2D(tMask, vUv).r;
          if (invertMask > 0.5) m = 1.0 - m;

          // Soften edge into a matte (0 outside, 1 inside)
          float matte = smoothstep(threshold - feather, threshold + feather, m);

          // If near object present here -> DISAPPEAR (discard bar pixel)
          if (matte > 0.5) discard;

          // Otherwise, draw bar (white)
          gl_FragColor = vec4(1.0);
        }
      `
    });

    function updateMaskUniforms() {
      barsMat.uniforms.threshold.value = CFG.maskThreshold;
      barsMat.uniforms.feather.value = CFG.maskFeather;
      barsMat.uniforms.invertMask.value = CFG.invertMask ? 1.0 : 0.0;
    }

    function bindCheckbox(id, key, onChange) {
      const el = document.getElementById(id);
      if (!el) return;
      el.checked = !!CFG[key];
      const apply = () => {
        CFG[key] = el.checked;
        if (onChange) onChange(CFG[key]);
      };
      el.addEventListener('change', apply);
      apply();
    }

    function bindRange(id, key, options = {}) {
      const el = document.getElementById(id);
      if (!el) return;
      const out = document.querySelector(`[data-out="${id}"]`);
      const parse = options.parse || parseFloat;
      const format = options.format || ((v) => v.toFixed(options.decimals ?? 2));
      const apply = () => {
        const value = parse(el.value);
        CFG[key] = value;
        if (out) out.textContent = format(value);
        if (options.onChange) options.onChange(value);
      };
      el.addEventListener('input', apply);
      el.value = CFG[key];
      apply();
    }

    const depthMinEl = document.getElementById('depthMin');
    const depthMaxEl = document.getElementById('depthMax');
    const syncDepth = () => {
      const rawMin = parseFloat(depthMinEl.value);
      const rawMax = parseFloat(depthMaxEl.value);
      const minVal = Math.min(0.99, Math.max(0, isNaN(rawMin) ? CFG.depthMin : rawMin));
      const maxVal = Math.max(minVal + 0.01, Math.min(1, isNaN(rawMax) ? CFG.depthMax : rawMax));
      depthMinEl.value = minVal.toFixed(2);
      depthMaxEl.value = maxVal.toFixed(2);
      CFG.depthMin = minVal;
      CFG.depthMax = maxVal;
      const minOut = document.querySelector('[data-out="depthMin"]');
      const maxOut = document.querySelector('[data-out="depthMax"]');
      if (minOut) minOut.textContent = minVal.toFixed(2);
      if (maxOut) maxOut.textContent = maxVal.toFixed(2);
    };

    bindCheckbox('stereoSideBySide', 'stereoSideBySide');
    bindCheckbox('swapStereo', 'swapStereo');
    bindCheckbox('flipX', 'flipX');
    bindCheckbox('flipY', 'flipY');
    bindCheckbox('invertMask', 'invertMask', updateMaskUniforms);
    bindRange('maxDisparity', 'maxDisparity', { parse: parseInt, format: (v) => `${v}` });
    bindRange('depthGamma', 'depthGamma', { decimals: 2 });
    bindCheckbox('depthBinary', 'depthBinary');
    bindRange('depthCutoff', 'depthCutoff', { decimals: 2 });
    bindRange('depthCutoffFeather', 'depthCutoffFeather', { decimals: 2 });
    bindRange('maskThreshold', 'maskThreshold', { decimals: 2, onChange: updateMaskUniforms });
    bindRange('maskFeather', 'maskFeather', { decimals: 2, onChange: updateMaskUniforms });
    bindRange('matchWindow', 'matchWindow', { parse: parseInt, format: (v) => `${v}` });
    bindRange('maxAvgCost', 'maxAvgCost', { parse: parseInt, format: (v) => `${v}` });
    bindRange('minUniqueness', 'minUniqueness', { parse: parseInt, format: (v) => `${v}` });
    bindRange('procScale', 'procScale', { decimals: 2 });
    bindRange('depthIntervalMs', 'depthIntervalMs', { parse: parseInt, format: (v) => `${v}` });
    if (depthMinEl && depthMaxEl) {
      depthMinEl.value = CFG.depthMin.toFixed(2);
      depthMaxEl.value = CFG.depthMax.toFixed(2);
      depthMinEl.addEventListener('input', syncDepth);
      depthMaxEl.addEventListener('input', syncDepth);
      syncDepth();
    }

    // === Build horizontal bars as thin planes ===
    const bars = [];
    const aspect = () => (innerWidth / innerHeight);
    const barWidth = () => aspect() * 2.2; // cover whole view with margin

    const barGeo = new THREE.PlaneGeometry(1, 1);
    for (let i = 0; i < CFG.barsCount; i++) {
      const mesh = new THREE.Mesh(barGeo, barsMat);
      scene.add(mesh);
      bars.push(mesh);
    }

    function layoutBars() {
      const a = aspect();
      const w = barWidth();
      const total = CFG.barsCount;
      const spacing = CFG.barsThickness + CFG.barsGap;
      const startY = -1 - spacing; // start slightly below view
      for (let i = 0; i < total; i++) {
        const b = bars[i];
        b.scale.set(w, CFG.barsThickness * 2.0, 1);
        b.position.set(0, startY + i * spacing, 0);
      }
    }
    layoutBars();

    let videoReady = false;
    let lastDepthTime = 0;

    const procLeft = document.createElement('canvas');
    const procRight = document.createElement('canvas');
    const procDepth = document.createElement('canvas');
    const procLeftCtx = procLeft.getContext('2d', { willReadFrequently: true });
    const procRightCtx = procRight.getContext('2d', { willReadFrequently: true });
    const procDepthCtx = procDepth.getContext('2d', { willReadFrequently: true });
    procDepthCtx.imageSmoothingEnabled = false;

    // === Webcam (stereo side-by-side) ===
    async function startCamera() {
      statusEl.textContent = "Requesting camera permission…";

      // Try to request a decent resolution; your stereo device may ignore constraints.
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 1280 },
          height: { ideal: 480 },
          frameRate: { ideal: 30 }
        },
        audio: false
      });

      video.srcObject = stream;
      await video.play();

      videoReady = true;
      statusEl.textContent =
        "Camera started. Depth map active. Use the controls in the HUD. Press D for debug.";
    }

    function getSourceDims(src) {
      if ('videoWidth' in src) return { w: src.videoWidth, h: src.videoHeight };
      return { w: src.width, h: src.height };
    }

    function drawTransformed(ctx, src, sx, sy, sw, sh, dw, dh, flipX, flipY) {
      ctx.save();
      ctx.clearRect(0, 0, dw, dh);
      ctx.translate(dw / 2, dh / 2);
      ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
      ctx.drawImage(src, sx, sy, sw, sh, -dw / 2, -dh / 2, dw, dh);
      ctx.restore();
    }

    function drawEye(ctx, src, eye, dw, dh, flipX, flipY) {
      const { w: vw, h: vh } = getSourceDims(src);
      if (!vw || !vh) return;

      if (!CFG.stereoSideBySide) {
        drawTransformed(ctx, src, 0, 0, vw, vh, dw, dh, flipX, flipY);
        return;
      }

      const halfW = Math.floor(vw / 2);
      const leftX = CFG.swapStereo ? halfW : 0;
      const rightX = CFG.swapStereo ? 0 : halfW;
      const sx = (eye === 'left') ? leftX : rightX;
      drawTransformed(ctx, src, sx, 0, halfW, vh, dw, dh, flipX, flipY);
    }

    function smoothstep(edge0, edge1, x) {
      const denom = edge1 - edge0;
      if (Math.abs(denom) < 1e-6) return x < edge0 ? 0 : 1;
      const t = Math.min(1, Math.max(0, (x - edge0) / denom));
      return t * t * (3 - 2 * t);
    }

    // === Per-frame: compute disparity-based depth mask from stereo frames ===
    function tickDepth(t) {
      if (!videoReady) return;
      if (t - lastDepthTime < CFG.depthIntervalMs) return;
      lastDepthTime = t;

      const vw = video.videoWidth;
      const vh = video.videoHeight;
      if (vw === 0 || vh === 0) return;

      // Debug views (flipped for display only)
      drawEye(leftCtx, video, 'left', leftCanvas.width, leftCanvas.height, CFG.flipX, CFG.flipY);
      drawEye(rightCtx, video, 'right', rightCanvas.width, rightCanvas.height, CFG.flipX, CFG.flipY);

      if (!CFG.stereoSideBySide) return;

      const scale = Math.min(1, Math.max(0.2, CFG.procScale));
      const eyeWidth = CFG.stereoSideBySide ? Math.floor(vw / 2) : vw;
      const W = Math.max(64, Math.round(eyeWidth * scale));
      const H = Math.max(48, Math.round(vh * scale));
      if (procLeft.width !== W || procLeft.height !== H) {
        procLeft.width = W;
        procLeft.height = H;
        procRight.width = W;
        procRight.height = H;
        procDepth.width = W;
        procDepth.height = H;
        procDepthCtx.imageSmoothingEnabled = false;
      }

      // Processing views (no flips; keep native stereo alignment)
      drawEye(procLeftCtx, video, 'left', W, H, false, false);
      drawEye(procRightCtx, video, 'right', W, H, false, false);

      const leftData = procLeftCtx.getImageData(0, 0, W, H).data;
      const rightData = procRightCtx.getImageData(0, 0, W, H).data;
      const depthImage = procDepthCtx.createImageData(W, H);
      const depthData = depthImage.data;

      const maxD = Math.min(CFG.maxDisparity, W - 1);
      const depthMin = Math.min(CFG.depthMin, CFG.depthMax - 0.01);
      const depthMax = Math.max(depthMin + 0.01, CFG.depthMax);
      const depthRange = Math.max(0.01, depthMax - depthMin);
      const radius = Math.max(0, Math.floor(CFG.matchWindow));
      const area = (radius * 2 + 1) * (radius * 2 + 1);
      const searchDir = CFG.swapStereo ? 1 : -1;
      const leftBound = radius + (searchDir < 0 ? maxD : 0);
      const rightBound = (W - 1) - radius - (searchDir > 0 ? maxD : 0);

      const grayL = new Float32Array(W * H);
      const grayR = new Float32Array(W * H);
      for (let i = 0; i < W * H; i++) {
        const idx = i * 4;
        grayL[i] = 0.2126 * leftData[idx] + 0.7152 * leftData[idx + 1] + 0.0722 * leftData[idx + 2];
        grayR[i] = 0.2126 * rightData[idx] + 0.7152 * rightData[idx + 1] + 0.0722 * rightData[idx + 2];
      }

      for (let y = 0; y < H; y++) {
        const row = y * W;
        for (let x = 0; x < W; x++) {
          const idx = (row + x) * 4;
          if (x < leftBound || x > rightBound || y < radius || y >= H - radius) {
            depthData[idx] = 0;
            depthData[idx + 1] = 0;
            depthData[idx + 2] = 0;
            depthData[idx + 3] = 255;
            continue;
          }

          let bestDisp = 0;
          let bestCost = 1e9;
          let secondBest = 1e9;

          for (let d = 0; d <= maxD; d += CFG.disparityStep) {
            let sum = 0;
            for (let ky = -radius; ky <= radius; ky++) {
              const yoff = (y + ky) * W;
              for (let kx = -radius; kx <= radius; kx++) {
                const l = grayL[yoff + x + kx];
                const r = grayR[yoff + x + kx + (searchDir * d)];
                sum += Math.abs(l - r);
              }
            }

            const avgCost = sum / area;
            if (avgCost < bestCost) {
              secondBest = bestCost;
              bestCost = avgCost;
              bestDisp = d;
            } else if (avgCost < secondBest) {
              secondBest = avgCost;
            }
          }

          let depth = 0;
          if (bestCost <= CFG.maxAvgCost && (secondBest - bestCost) >= CFG.minUniqueness) {
            const dispNorm = maxD > 0 ? (bestDisp / maxD) : 0;
            let t = (dispNorm - depthMin) / depthRange;
            t = Math.max(0, Math.min(1, t));
            depth = Math.pow(t, Math.max(0.01, CFG.depthGamma));
            if (CFG.invertMask) depth = 1 - depth;
            if (CFG.depthBinary) {
              depth = smoothstep(
                CFG.depthCutoff - CFG.depthCutoffFeather,
                CFG.depthCutoff + CFG.depthCutoffFeather,
                depth
              );
            }
          }
          const v = Math.round(depth * 255);
          depthData[idx] = v;
          depthData[idx + 1] = v;
          depthData[idx + 2] = v;
          depthData[idx + 3] = 255;
        }
      }

      procDepthCtx.putImageData(depthImage, 0, 0);
      drawTransformed(
        maskCtx,
        procDepth,
        0,
        0,
        procDepth.width,
        procDepth.height,
        maskCanvas.width,
        maskCanvas.height,
        CFG.flipX,
        CFG.flipY
      );
      maskTexture.needsUpdate = true;
    }

    // === Animation loop ===
    let lastT = performance.now();

    function animate(t) {
      requestAnimationFrame(animate);

      const dt = Math.min(0.05, (t - lastT) / 1000);
      lastT = t;

      // Move bars upward; wrap around
      const spacing = CFG.barsThickness + CFG.barsGap;
      const top = 1 + spacing * 2;
      const bottom = -1 - spacing * 2;

      for (const b of bars) {
        b.position.y += CFG.barsSpeed * dt;
        if (b.position.y > top) b.position.y = bottom;
      }

      // Update depth mask from stereo disparity
      tickDepth(t);

      // Render
      renderer.render(scene, camera);
    }

    // === UX toggles ===
    addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'd') {
        debugWrap.style.display = (debugWrap.style.display === 'none') ? 'flex' : 'none';
      }
      if (e.key.toLowerCase() === 'f') {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
      }
    });

    // Start
    startCamera()
      .then(() => {
        layoutBars();
        requestAnimationFrame(animate);
      })
      .catch((err) => {
        console.error(err);
        statusEl.textContent = "Camera error: " + (err?.message || err);
      });
  </script>
</body>
</html>
