<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Particle Engine 1080p</title>
    <style>
        body {
            margin: 0;
            background-color: #050505;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }

        #canvas-wrapper {
            position: relative;
            /* Force 16:9 aspect ratio */
            width: 100%;
            max-width: 1920px;
            aspect-ratio: 16 / 9; 
            max-height: 100vh;
            background-color: #000;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border: 1px solid #222;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            pointer-events: none;
            opacity: 0.6;
        }
    </style>
</head>
<body>

    <div id="canvas-wrapper">
        <canvas id="world"></canvas>
        <div class="ui-layer">
            <h3>Particle Emitter</h3>
            <p>Emitter: Center | Attractor: Mouse</p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.18.0/dist/lil-gui.umd.min.js"></script>

    <script>
        // --- 1. Setup Canvas & Context ---
        const canvas = document.getElementById('world');
        const ctx = canvas.getContext('2d');

        // Internal resolution (1080p)
        const width = 1920;
        const height = 1080;
        canvas.width = width;
        canvas.height = height;

        // Mouse State (Default to center-ish so particles flow somewhere initially)
        const mouse = { x: width * 0.7, y: height * 0.5, active: false };

        function canvasToWorld(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }

        // Handle Mouse Coordinates relative to the scaled canvas
        canvas.addEventListener('mousemove', (e) => {
            const pos = canvasToWorld(e);
            mouse.x = pos.x;
            mouse.y = pos.y;
            mouse.active = true;
        });

        // --- 2. Configuration & GUI ---
        const config = {
            // Emission
            emitRate: 5,         // Particles per frame
            particleSpeed: 14.63,
            lifeSpan: 200,       // How long particles live
            
            // Visuals
            startColor: '#ffffff',
            endColor: '#0000ff',
            lineWidth: 2,
            fadeEffect: 0.1,     // Trail fade (lower = longer trails)

            // Mask
            maskImageSrc: 'fern.jpg',

            // Physics
            randomness: 1.975,     // Jitter/Noise
            friction: 0.95969,      // Air resistance
            
            // Attractor
            attractRadius: 649.8,
            attractStrength: 1.8081,
            enableAttractor: true,

            // Repulsion
            enableRepulsion: true,
            repulseRadius: 250,
            repulseStrength: 1.2
        };

        const gui = new lil.GUI({ title: 'Engine Settings' });
        
        const fVisuals = gui.addFolder('Visuals');
        fVisuals.addColor(config, 'startColor').name('Start Color');
        fVisuals.addColor(config, 'endColor').name('End Color');
        fVisuals.add(config, 'lineWidth', 0.1, 10).name('Line Width');
        fVisuals.add(config, 'fadeEffect', 0.01, 0.5).name('Trail Fade (Clear)').step(0.01);

        const fPhysics = gui.addFolder('Movement');
        fPhysics.add(config, 'particleSpeed', 1, 20).name('Launch Speed');
        fPhysics.add(config, 'randomness', 0, 5).name('Randomness (Jitter)');
        fPhysics.add(config, 'friction', 0.8, 0.99).name('Friction');

        const fAttract = gui.addFolder('Attractor');
        fAttract.add(config, 'enableAttractor').name('Enable Mouse Pull');
        fAttract.add(config, 'attractRadius', 50, 1000).name('Range');
        fAttract.add(config, 'attractStrength', 0.1, 5).name('Strength');

        const fRepulse = gui.addFolder('Repulsion');
        fRepulse.add(config, 'enableRepulsion').name('Enable Click Push');
        fRepulse.add(config, 'repulseRadius', 50, 1000).name('Radius');
        fRepulse.add(config, 'repulseStrength', 0.1, 5).name('Strength');

        const trailCanvas = document.createElement('canvas');
        const trailCtx = trailCanvas.getContext('2d');
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');
        const imageCanvas = document.createElement('canvas');
        const imageCtx = imageCanvas.getContext('2d');

        [trailCanvas, maskCanvas, imageCanvas].forEach((surface) => {
            surface.width = width;
            surface.height = height;
        });

        const maskImage = new Image();
        maskImage.decoding = 'async';
        maskImage.src = config.maskImageSrc;
        let maskImageReady = false;
        maskImage.onload = () => {
            maskImageReady = true;
        };
        maskImage.onerror = () => {
            maskImageReady = false;
        };

        // --- 3. Helper Functions ---
        
        // Convert Hex to RGB for interpolation
        function hexToRgb(hex) {
            const bigint = parseInt(hex.replace('#', ''), 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }

        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        function drawImageCover(ctx, image, targetWidth, targetHeight) {
            const imageRatio = image.width / image.height;
            const targetRatio = targetWidth / targetHeight;
            let drawWidth = targetWidth;
            let drawHeight = targetHeight;
            let offsetX = 0;
            let offsetY = 0;

            if (imageRatio > targetRatio) {
                drawHeight = targetHeight;
                drawWidth = targetHeight * imageRatio;
                offsetX = (targetWidth - drawWidth) * 0.5;
            } else {
                drawWidth = targetWidth;
                drawHeight = targetWidth / imageRatio;
                offsetY = (targetHeight - drawHeight) * 0.5;
            }

            ctx.drawImage(image, offsetX, offsetY, drawWidth, drawHeight);
        }

        // --- 4. Particle System ---
        
        let particles = [];
        let repulsor = null;

        canvas.addEventListener('click', (e) => {
            if (!config.enableRepulsion) return;
            const pos = canvasToWorld(e);
            if (!repulsor) {
                repulsor = { x: pos.x, y: pos.y };
            } else {
                repulsor.x = pos.x;
                repulsor.y = pos.y;
            }
        });

        class Particle {
            constructor() {
                // Start at center
                this.x = width / 2;
                this.y = height / 2;
                
                // Random initial velocity
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * config.particleSpeed;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                // Track previous position for drawing smooth lines
                this.prevX = this.x;
                this.prevY = this.y;

                this.life = 0;
                this.maxLife = config.lifeSpan + Math.random() * 50;
                this.dead = false;
            }

            update() {
                // 1. Save previous position
                this.prevX = this.x;
                this.prevY = this.y;

                // 2. Attractor Physics
                if (config.enableAttractor && mouse.active) {
                    const dx = mouse.x - this.x;
                    const dy = mouse.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < config.attractRadius) {
                        // Calculate pull force (stronger when closer)
                        const force = config.attractStrength * (1 - dist / config.attractRadius);
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                }

                // 3. Repulsors
                if (config.enableRepulsion && repulsor) {
                    const dx = this.x - repulsor.x;
                    const dy = this.y - repulsor.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0 && dist < config.repulseRadius) {
                        const force = config.repulseStrength * (1 - dist / config.repulseRadius);
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                }

                // 4. Randomness (Jitter)
                this.vx += (Math.random() - 0.5) * config.randomness;
                this.vy += (Math.random() - 0.5) * config.randomness;

                // 5. Move
                this.x += this.vx;
                this.y += this.vy;

                // 6. Friction
                this.vx *= config.friction;
                this.vy *= config.friction;

                // 7. Aging
                this.life++;
                if (this.life > this.maxLife) {
                    this.dead = true;
                }
            }

            draw(trailCtx, maskCtx) {
                const progress = this.life / this.maxLife;
                const startRgb = hexToRgb(config.startColor);
                const whiteAlpha = Math.max(0, 1 - progress);

                trailCtx.strokeStyle = `rgba(${startRgb[0]},${startRgb[1]},${startRgb[2]},${whiteAlpha})`;
                trailCtx.lineWidth = config.lineWidth;
                trailCtx.lineCap = 'round';

                trailCtx.beginPath();
                trailCtx.moveTo(this.prevX, this.prevY);
                trailCtx.lineTo(this.x, this.y);
                trailCtx.stroke();

                maskCtx.strokeStyle = `rgba(255,255,255,${progress})`;
                maskCtx.lineWidth = config.lineWidth;
                maskCtx.lineCap = 'round';

                maskCtx.beginPath();
                maskCtx.moveTo(this.prevX, this.prevY);
                maskCtx.lineTo(this.x, this.y);
                maskCtx.stroke();
            }
        }

        // --- 5. Animation Loop ---

        function animate() {
            // Create trails by fading the offscreen buffers.
            trailCtx.fillStyle = `rgba(0, 0, 0, ${config.fadeEffect})`;
            trailCtx.fillRect(0, 0, width, height);
            maskCtx.globalCompositeOperation = 'destination-out';
            maskCtx.fillStyle = `rgba(0, 0, 0, ${config.fadeEffect})`;
            maskCtx.fillRect(0, 0, width, height);
            maskCtx.globalCompositeOperation = 'source-over';

            // Spawn new particles
            for (let i = 0; i < config.emitRate; i++) {
                particles.push(new Particle());
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw(trailCtx, maskCtx);

                if (p.dead) {
                    particles.splice(i, 1);
                }
            }

            // Compose final frame
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            ctx.drawImage(trailCanvas, 0, 0);

            if (maskImageReady) {
                imageCtx.clearRect(0, 0, width, height);
                drawImageCover(imageCtx, maskImage, width, height);
                imageCtx.globalCompositeOperation = 'destination-in';
                imageCtx.drawImage(maskCanvas, 0, 0);
                imageCtx.globalCompositeOperation = 'source-over';
                ctx.drawImage(imageCanvas, 0, 0);
            }

            // Draw repulsor rings
            if (config.enableRepulsion && repulsor) {
                ctx.strokeStyle = 'rgba(255, 120, 120, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(repulsor.x, repulsor.y, config.repulseRadius, 0, Math.PI * 2);
                ctx.stroke();
            }

            requestAnimationFrame(animate);
        }

        // Start
        animate();

    </script>
</body>
</html>
